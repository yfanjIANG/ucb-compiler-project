import java.util.ArrayList;
import java.util.List;


import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();
            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class that performs
 * production-rule actions. */
action code {:

    /** Return a mutable list initially containing the single value ITEM. */
    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** If ITEM is non-null, appends it to the end of LIST.  Then returns
     *  LIST. */
    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** Return a mutable empty list. */
    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    /** Return the leftmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }
    ComplexSymbolFactory.Location getRight(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node last = nodes.get(nodes.size() - 1);
        return new ComplexSymbolFactory.Location(last.getLocation()[2],
                                                 last.getLocation()[3]);
    }

:}

/* Terminal symbols (tokens returned by the lexer).  The declaration
 *     terminal <identifier1>, <identifier2>, ...;
 * declares each <identifieri> as the denotation of a distinct type terminal
 * symbol for use in the grammar.  The declaration
 *     terminal <type> <identifier1>, ...;
 * does the same, and in addition indicates that the lexer supplies a
 * semantic value of type <type> for these symbols that may be referenced
 * in actions ( {: ... :} ).
 */
terminal NEWLINE;
terminal String IDENTIFIER;
terminal String PLUS, MINUS, MULTIPLE, MOD, DIVIDE; 
terminal String COLON, DOT, ARROW, COMMA;
terminal Integer NUMBER; 
terminal String IS;
terminal String GREATER, LESS, GREATEREQ, LESSEQ, EQEQ, NOTEQ, EQ;
terminal String STRING_LITERAL;
terminal String LBRA, RBRA, LPAR, RPAR;

terminal TRUE, FALSE;
terminal NONE;
terminal AND, OR, NOT;
terminal IF, ELSE, WHILE, FOR, IN, ELIF;
terminal INDENT,DEDENT,CLASS;
terminal GLOBAL, NONLOCAL,PASS, RETURN, DEF;

/* Returned by the lexer for erroneous tokens.  Since it does not appear in
 * the grammar, it indicates a syntax error. */
terminal UNRECOGNIZED;   

/* Nonterminal symbols (defined in production rules below).
 * As for terminal symbols, 
 *     non terminal <type> <identifier1>, ..., <identifiern>; 
 * defines the listed nonterminal identifier symbols to have semantic values
 * of type <type>. */
non terminal Program            program;
non terminal List<Declaration>  program_head;
non terminal List<Stmt>         stmt_list, opt_stmt_list, block, else_block;
non terminal Stmt               stmt, expr_stmt;
non terminal Expr               expr, binary_expr, unary_expr, target;
non terminal Identifier         identifier;
non terminal List<Expr>         list_expr, target_eq_list;
non terminal IndexExpr          index_expr;
non terminal MemberExpr         member_expr;
non terminal TypeAnnotation     type;
non terminal TypedVar           typed_var;
non terminal VarDef             var_def;
non terminal Literal            literal;
non terminal List<TypedVar>     list_typed_var;
non terminal ClassDef           class_def;
non terminal List<Declaration>  class_body, func_decl;
non terminal GlobalDecl         global_decl;
non terminal NonLocalDecl       nonlocal_decl;
non terminal FuncDef            func_def;
non terminal TypeAnnotation     func_ret;



/* Precedences (lowest to highest) for resolving what would otherwise be
 * ambiguities in the form of shift/reduce conflicts.. */
precedence right IF, ELSE;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence nonassoc GREATER, LESS, GREATEREQ, LESSEQ, EQEQ, NOTEQ, IS;
precedence left PLUS, MINUS;
precedence left DIVIDE, MULTIPLE, MOD;
precedence nonassoc LBRA, RBRA, DOT;


/* The start symbol. */
start with program;


/*****  GRAMMAR RULES *****/

program ::= program_head:d opt_stmt_list:s
        {: RESULT = new Program(d.isEmpty() ? getLeft(s) : getLeft(d),
                                sxright, d, s, errors);
        :}
        ;

/* Initial list of declarations. */
program_head ::= /* not implemented; currently matches empty string */
                                             {: RESULT = empty(); :}
                | program_head:d var_def:x   {: RESULT = combine(d, x); :}
                | program_head:d class_def:x {: RESULT = combine(d, x); :}
                | program_head:d func_def:x  {: RESULT = combine(d, x); :}
                | program_head:d error:e     {: RESULT = d; :}
                ;

opt_stmt_list ::=                    {: RESULT = empty(); :}
                | stmt_list:s        {: RESULT = s; :}
                ;

stmt_list ::= stmt:s                 {: RESULT = single(s); :}
            | stmt_list:l stmt:s     {: RESULT = combine(l, s); :}
            | stmt_list:l error      {: RESULT = l; :}
            /* If there is a syntax error in the source, this says to discard
             * symbols from the parsing stack and perform reductions until
             * there is a stmt_list on top of the stack, and then to discard
             * input symbols until it is possible to shift again, reporting
             * a syntax error. */
            ;



stmt ::= expr_stmt:s NEWLINE                                               {: RESULT = s; :}
        | WHILE:wh expr:e COLON:co block:block                             {: RESULT = new WhileStmt(whxleft, getRight(block), e, block);:}
        | FOR:fo identifier:id IN expr:e COLON:colon block:block           {: RESULT = new ForStmt(foxleft, getRight(block), id, e, block);:}
        | IF:i expr:cond COLON block:b else_block:elb                      {: RESULT = new IfStmt(ixleft, getRight(elb), cond, b, elb); :}
        ;


expr_stmt ::= expr:e                                    {: RESULT = new ExprStmt(exleft, exright, e); :}
            | PASS                                      {: RESULT = null; :}
            | RETURN:ret expr:e                         {: RESULT = new ReturnStmt(retxleft, exright, e); :}
            | RETURN:ret                                {: RESULT = new ReturnStmt(retxleft,retxright, null); :}
            | target_eq_list: tel expr:e                {: RESULT = new AssignStmt(getLeft(tel), exright, tel, e); :}
            ;


var_def ::= typed_var:var EQ literal:liter NEWLINE      {: RESULT = new VarDef(varxleft, literxright,var, liter);:}
          ;

identifier ::= IDENTIFIER:id                            {: RESULT = new Identifier(idxleft, idxright, id); :}
            ;
typed_var ::= identifier:id COLON type:type             {: RESULT = new TypedVar(idxleft, typexright,id, type);:}
            ;

list_typed_var ::=   typed_var:tv                            {: RESULT = single(tv); :}
                 |list_typed_var:ltv COMMA:co typed_var:tv   {: RESULT = combine(ltv, tv); :}
                 | list_typed_var:ltv COMMA error                  {: RESULT= ltv; :}
                 |                                           {: RESULT = empty(); :}
                 ;

type ::= IDENTIFIER:id                      {: RESULT = new ClassType(idxleft, idxright, id); :}    
        | LBRA:lp type:type RBRA:rp         {: RESULT = new ListType(lpxleft, rpxright, type); :}
        | STRING_LITERAL:str                {: RESULT = new ClassType(strxleft, strxright, str); :}
       ;


literal ::= TRUE:t              {: RESULT = new BooleanLiteral(txleft, txright, true); :}
          | FALSE:f             {: RESULT = new BooleanLiteral(fxleft, fxright, false); :}
          | NONE:n              {: RESULT = new NoneLiteral(nxleft, nxright); :}
          | STRING_LITERAL:str  {: RESULT = new StringLiteral(strxleft, strxright, str); :}
          | NUMBER:n            {: RESULT = new IntegerLiteral(nxleft, nxright, n); :}
          ;



expr ::= identifier:id                                      {: RESULT = id; :}
       | identifier:id LPAR:lp list_expr:le RPAR:rp         {: RESULT = new CallExpr(idxleft, rpxright, id, le); :} //function call
       | binary_expr:e                                      {: RESULT = e; :}
       | unary_expr:e                                       {: RESULT = e; :} 
       | literal:lit                                        {: RESULT = lit; :}                                                 
       | LBRA:lb list_expr:le RBRA:rb                       {: RESULT = new ListExpr(lbxleft, rbxright, le); :}   // []
       | LPAR:lb expr:e RPAR:rp                             {: RESULT = e; :}                                           // (expr)
       | expr:then_exp IF expr:if_exp ELSE expr:else_expr   {: RESULT = new IfExpr(then_expxleft, else_exprxright, if_exp, then_exp, else_expr); :}
       | index_expr:e                                       {: RESULT = e; :}
       | member_expr:e                                      {: RESULT = e; :}
       | member_expr:e LPAR:lp list_expr:le RPAR:rp         {: RESULT = new MethodCallExpr(exleft, rpxright, e, le); :}
       ;



/* A binary expression, illustrating how to find the left and right
 * source position of a phrase. */
binary_expr ::= expr:e1 PLUS:op expr:e2         {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 MINUS:op expr:e2        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 MULTIPLE:op expr:e2     {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 DIVIDE:op expr:e2       {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 MOD:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 AND:and expr:e2         {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, "and", e2); :}
              | expr:e1 OR:or expr:e2           {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, "or", e2); :}
              | expr:e1 GREATER:op expr:e2      {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 LESS:op expr:e2         {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 GREATEREQ:op expr:e2    {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 LESSEQ:op expr:e2       {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 EQEQ:op expr:e2         {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 NOTEQ:op expr:e2        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 IS:op expr:e2           {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              ;



unary_expr ::= MINUS:op expr:e                  {: RESULT = new UnaryExpr(opxleft, exright, op, e); :}
            | NOT:not expr:e                    {: RESULT = new UnaryExpr(notxleft, exright, "not", e); :}
            ;



list_expr ::= expr:e                            {: RESULT = single(e); :}
            | list_expr:le COMMA:co expr:e      {: RESULT = combine(le, e); :}
            |                                   {: RESULT = empty(); :}
            ;

index_expr ::= expr:e1 LBRA:lb expr:e2 RBRA:rb  {: RESULT = new IndexExpr(e1xleft, rbxright, e1, e2); :}
            ;

member_expr ::= expr:e DOT:dot identifier:id    {: RESULT = new MemberExpr(exleft, idxright, e, id); :}
            ;

target ::= identifier:id        {: RESULT = id; :}
         | member_expr:me       {: RESULT = me; :}
         | index_expr:ie        {: RESULT = ie; :}
         ;

target_eq_list ::= target:t EQ:eq                       {: RESULT = single(t); :}
                 | target_eq_list:tel target:t EQ:eq    {: RESULT = combine(tel, t); :}
                 ;


class_def ::= CLASS:cl identifier:id1 LPAR identifier:id2 RPAR COLON:co NEWLINE INDENT class_body:body DEDENT 
            {: RESULT = new ClassDef(clxleft, getRight(body) , id1, id2, body);:}
            ;

class_body ::= PASS NEWLINE                     {: RESULT = empty(); :}
              |var_def:vd                       {: RESULT = single(vd) ;:}
              |class_body:body var_def:vd       {: RESULT = combine(body,vd) ;:}
              |func_def:def                     {: RESULT = single(def) ;:}
              |class_body:body func_def:def     {: RESULT = combine(body,def) ;:}
              |class_body:body error            {: RESULT = body; :}
              ;


global_decl ::= GLOBAL:gl identifier:id NEWLINE             {: RESULT = new GlobalDecl(glxleft, idxright, id); :};

nonlocal_decl ::= NONLOCAL:nl identifier:id NEWLINE         {: RESULT = new NonLocalDecl(nlxleft, idxright, id); :};

func_def  ::= DEF:def identifier:id LPAR list_typed_var:ltv RPAR func_ret:ret COLON:co NEWLINE INDENT func_decl:fd stmt_list:sl DEDENT
            {: RESULT = new FuncDef(defxleft, getRight(sl), id, ltv, ret == null ? new ClassType(coxleft, coxleft, "<None>") : ret, fd, sl); :}
           ;


func_decl ::= func_decl:fd var_def:vd                             {: RESULT = combine(fd, vd); :}
            | func_decl:fd func_def:def                           {: RESULT = combine(fd, def); :}
            | func_decl:fd global_decl:gl                         {: RESULT = combine(fd, gl); :}
            | func_decl:fd nonlocal_decl:nl                       {: RESULT = combine(fd, nl); :}
            | func_decl:fd  error                                 {: RESULT= fd; :} 
            |                                                     {: RESULT = empty(); :}
            ;

func_ret  ::= ARROW:arrow type:t    {: RESULT = t; :}
            |                       {: RESULT = null; :}
            ;


block ::= NEWLINE INDENT stmt_list:sl DEDENT   {: RESULT = sl; :}
        ;




else_block ::= ELSE:el COLON block:b                                         {: RESULT = b; :}
            |  ELIF:el expr:cond COLON block:b else_block:elb                {: RESULT = single(new IfStmt(elxleft, getRight(elb), cond, b, elb)); :}
            |                                                                {: RESULT = empty(); :}
            ;
